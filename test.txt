# ===== Benchmark: AUC-per-feature — sequential vs parallel =====
import numpy as np
import pandas as pd
import time
from joblib import Parallel, delayed
from sklearn.datasets import make_classification
from sklearn.metrics import roc_auc_score
from sklearn.model_selection import StratifiedKFold
import lightgbm as lgb

# ---- Scale knobs ----
ROWS_PER_YEAR     = 2500     # increase/decrease as you like
N_FEATURES_TOTAL  = 4000       # total features in the dataset
N_FEATURES_BENCH  = 4000       # how many features to benchmark (use 4000 for full test)

# ---- Data settings ----
YEARS      = range(2018, 2023) # 2018–2022
POS_RATIO  = 0.06              # unbalanced: 10% positives
RNG_SEED   = 42

# ---- LGBM settings ----
CV_FOLDS   = 3
ES_ROUNDS  = 10
N_ESTIMATORS = 100

# --------- Generate 2018–2022 unbalanced dataset ----------
def create_year_df(year, n_rows, n_features, pos_ratio, rng_seed):
    X, y = make_classification(
        n_samples=n_rows,
        n_features=n_features,
        n_informative=max(2, n_features // 20),
        n_redundant=max(0, n_features // 20),
        n_repeated=0,
        n_classes=2,
        weights=[1 - pos_ratio, pos_ratio],
        class_sep=1.0,
        random_state=rng_seed + year,
    )
    cols = [f"f{i}" for i in range(n_features)]
    df = pd.DataFrame(X, columns=cols)
    df["y"] = y
    df["year"] = year
    return df

dfs = [create_year_df(y, ROWS_PER_YEAR, N_FEATURES_TOTAL, POS_RATIO, RNG_SEED) for y in YEARS]
data = pd.concat(dfs, ignore_index=True)

X = data.drop(columns=["y", "year"])
y = data["y"].values
cols = [f"f{i}" for i in range(N_FEATURES_BENCH)]
Xb = X[cols].copy()

print(f"Rows: {X.shape[0]:,} | Features (bench): {Xb.shape[1]}")
print(f"Class balance: positives={y.sum()} ({y.mean()*100:.2f}%)\n")

# --------- A) Raw AUC (no model) ----------
def raw_auc_for_feature(x, y):
    m = ~np.isnan(x)
    x, y = x[m], y[m]
    if len(np.unique(y)) < 2 or len(x) < 3 or np.allclose(x, x[0]):
        return np.nan
    return roc_auc_score(y, x)

# --------- B) Per-feature LightGBM CV AUC ----------
def lgb_cv_auc_for_feature(x, y, cv=3, es_rounds=20, n_estimators=300, seed=RNG_SEED):
    m = ~np.isnan(x)
    Xc, yc = x[m].reshape(-1, 1), y[m]
    if len(np.unique(yc)) < 2 or Xc.shape[0] < 3 or np.allclose(Xc, Xc[0]):
        return np.nan
    skf = StratifiedKFold(n_splits=cv, shuffle=True, random_state=seed)
    params = dict(
        objective="binary",
        n_estimators=n_estimators,
        learning_rate=0.05,
        num_leaves=7,
        is_unbalance=True,   # helpful for 10% positives
        n_jobs=1,            # IMPORTANT: single-threaded inside
        verbose=-1
    )
    aucs = []
    for tr, va in skf.split(Xc, yc):
        clf = lgb.LGBMClassifier(**params)
        clf.fit(
            Xc[tr], yc[tr],
            eval_set=[(Xc[va], yc[va])],
            eval_metric="auc",
            callbacks=[lgb.early_stopping(es_rounds, verbose=False)],
        )
        p = clf.predict_proba(Xc[va])[:, 1]
        aucs.append(roc_auc_score(yc[va], p))
    return float(np.mean(aucs))

# --------- Timing helpers ----------
def time_run(func, Xdf, y, n_jobs, label):
    t0 = time.perf_counter()
    if n_jobs == 1:
        scores = [func(Xdf[c].to_numpy(dtype=float), y) for c in Xdf.columns]
    else:
        scores = Parallel(n_jobs=n_jobs, backend="loky")(
            delayed(func)(Xdf[c].to_n umpy(dtype=float), y) for c in Xdf.columns
        )
    dt = time.perf_counter() - t0
    scores = np.array(scores, dtype=float)
    print(f"[{label}] {len(scores)} feats | time={dt:.2f}s | "
          f"median AUC={np.nanmedian(scores):.4f} | kept(>0.5)={(scores>0.5).sum()}")
    return dt, scores

# --------- Run: RAW AUC (no model) ---------
print("=== RAW AUC (no model) ===")
t_raw_seq, _ = time_run(raw_auc_for_feature, Xb, y, n_jobs=1,  label="Sequential")
t_raw_par, _  = time_run(raw_auc_for_feature, Xb, y, n_jobs=-1, label="Parallel (-1)")
print(f"Speedup (parallel / sequential): {t_raw_seq / t_raw_par:.2f}×\n")

# --------- Run: LightGBM per-feature CV AUC ---------
print("=== LightGBM per-feature CV AUC ===")
t_lgb_seq, _ = time_run(
    lambda col, y: lgb_cv_auc_for_feature(col, y, cv=CV_FOLDS, es_rounds=ES_ROUNDS, n_estimators=N_ESTIMATORS),
    Xb, y, n_jobs=1, label="Sequential"
)
t_lgb_par, _  = time_run(
    lambda col, y: lgb_cv_auc_for_feature(col, y, cv=CV_FOLDS, es_rounds=ES_ROUNDS, n_estimators=N_ESTIMATORS),
    Xb, y, n_jobs=-1, label="Parallel (-1)"
)
print(f"Speedup (parallel / sequential): {t_lgb_seq / t_lgb_par:.2f}×")

